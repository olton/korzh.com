const id = "2019-05-07-add-extra-user-claims-aspnet-core-webapp.mdx";
						const collection = "blog";
						const slug = "add-extra-user-claims-aspnet-core-webapp";
						const body = "import {Image} from \"astro:assets\";\r\nimport claim01Image from \"../../images/blog/anc22-add-extra-claim01.png\"\r\nimport claim02Image from \"../../images/blog/anc22-add-extra-claim02.png\"\r\nimport claim03Image from \"../../images/blog/anc22-add-extra-claim03.png\"\r\n\r\n## Introduction\r\n\r\nThis is a second edition of the [previous post on the same topic](aspnet-identity-store-user-data-in-claims). The reason why I wrote this one is because of some drastic changes made in ASP.NET Core Authentication system from version 2.0 to version 2.2 - so most of the code presented in the first article doesn't work with the new version.\r\n\r\nSo, the code in the following articles was built for and tested with ASP.NET Core 2.2. The main concept, however, is still the same and were not changed since ASP.NET Identity 2.0 (I guess).\r\n\r\nAs in the previous case, we will start with a description of the problem.\r\n\r\n## Problem\r\n\r\nLet's suppose we created a new ASP.NET Core project using one of the default templates and chose \"Individual user account\" option for \"Authentication\".\r\n<Image src={claim01Image} alt=\"ASP.NET Core - new webapp project with an authentication\" />\r\n\r\nNow when we start that newly created project and register new user we will see something like `Hello YourEmailAddress@YourCompany.com` in the top right part of the index web-page.\r\n\r\nObviously, such kind of greeting is useless in a real-world application and you would like to see the name of the currently logged user there instead (e.g. `Hello John Doe`).\r\nLet's figure out how to do it.\r\n\r\n## Solution\r\n\r\nHere we guess you are already familiar with the claims and [claims-based approach](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims) for authorization used in ASP.NET Core Identity. If not - please read [ASP.NET Core Security](https://docs.microsoft.com/en-us/aspnet/core/security/) article first.\r\n\r\nTo achieve our goal we need to do 2 things:\r\n\r\n1. Add necessary information to the list of the claims attached to the user's identity.\r\n2. Have a simple way of getting that info when needed.\r\n\r\nBut before implementing these two tasks we will need to add a new ContactName field to our model class and update our registration and user management pages accordingly.\r\n\r\n## Step 0: Preparations\r\n\r\nBefore we can add a new claim to a user object (the one you can access via `HttpContext.User`) we need a place to store that additional info somewhere.\r\nHere I am going to describe how to get this done for a new ASP.NET Core project built by a default template.\r\n\r\nIf already you work with your real-world application - you most probably already did similar changes before.\r\nIn this case, you can skip this section and move right to the step #1.\r\n\r\n### 0.1 New ApplicationUser class\r\n\r\nAdd a new  `ApplicationUser` class with `ContactName' property:\r\n\r\n```csharp\r\npublic class ApplicationUser : IdentityUser\r\n{\r\n    public string ContactName { get; set; }\r\n}\r\n```\r\n\r\nOf course, you can add more properties to store some additional information with the user account.\r\nFor example: `FirstName`, `LastName`, `Country`, `Address`, etc. All of them can be placed to claims the same way as `ContactName` we discuss here.\r\n\r\n### 0.2 Replace `IdentityUser` with `ApplicationUser`\r\n\r\nNow you need to replace `IdentityUser` with `ApplicationUser` everywhere in your project.\r\n\r\nThe default ASP.NET Core template uses predefined `IdentityUser` type everywhere.\r\nSince we what to use `ApplicationUser` instead of it - we need to search for all inclusions of `IdentityUser` in your project and replace with `ApplicationUser`.\r\n\r\nIt will include your DbContext class, one line in `Startup` class (in `ConfigureServices` method) and two lines with `@inject` directives in `_LoginPartial.cshtml` view.\r\n\r\nHere is how your new `ApplicationDbContext` class will look like after that:\r\n\r\n```csharp\r\npublic class ApplicationDbContext : IdentityDbContext<ApplicationUser, IdentityRole, string>\r\n{\r\n    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)\r\n        : base(options)\r\n    {\r\n    }\r\n}\r\n```\r\n\r\n### 0.3. Update your database.\r\n\r\nNow you need to add a new migration and then update your DB.\r\nJust run the following 2 commands from your project's folder:\r\n\r\n```shell\r\ndotnet ef migrations add AddUserContactName\r\n\r\ndotnet ef database update\r\n```\r\n\r\n### 0.4. Update \"User Profile\" page\r\n\r\nFinally, we will need to add our new field to the \"User Profile\" page to make it possible for users to modify it.\r\n\r\nThe default ASP.NET Core template uses all identity-related pages directly from a special Razor UI library (`Microsoft.AspNetCore.Identity.UI`).\r\nThe good news is: we can override any of those pages if we want. Here are the steps we need to do:\r\n\r\n1. Right-click on your project in VS and select Add | New Scaffolding item.\r\n\r\n2. In the \"Add Scaffold\" dialog select `Identity` on the left side tree and then `Identity` in the main list and click \"Add\".\r\n\r\n3. In the dialog that appears select only `Account\\Manage\\Index` page and then click on \"Add\" as well.\r\nWhen the process is finished you will find a new page 'Index.cshtml' in `Areas/Identity/Pages` folder.\r\n\r\n4. After that make the following changes to that `Index` page:\r\n\r\nIn the Index.cshtml itself add the following piece of markup right before `update-profile-button` button.\r\n\r\n```html\r\n<div class=\"form-group\">\r\n    <label asp-for=\"Input.ContactName\"></label>\r\n    <input asp-for=\"Input.ContactName\" class=\"form-control\" />\r\n    <span asp-validation-for=\"Input.ContactName\" class=\"text-danger\"></span>\r\n</div>\r\n```\r\n\r\nThen, in the code-behind file `Index.cshtml.cs` we need to modify the view model:\r\n\r\n```csharp\r\npublic class InputModel\r\n{\r\n    .   .   .   .   .   .\r\n\r\n    public string ContactName { get; set; }\r\n}\r\n```\r\n\r\nthen the `OnGetAsync` method:\r\n\r\n```csharp\r\npublic async Task<IActionResult> OnGetAsync()\r\n{\r\n    .   .   .   .   .   .\r\n\r\n    Input = new InputModel\r\n\t{\r\n\t\tEmail = email,\r\n\t\tPhoneNumber = phoneNumber,\r\n\t\tContactName = user.ContactName //add this line\r\n\t};\r\n\r\n    .   .   .   .   .   .\r\n\r\n}\r\n```\r\n\r\nand the `OnPutAsync`:\r\n\r\n```csharp\r\npublic async Task<IActionResult> OnPostAsync()\r\n{\r\n    .    .    .    .    .    .    .\r\n\r\n\tif (Input.ContactName != user.ContactName) {\r\n\t\tuser.ContactName = Input.ContactName;\r\n\t\tawait _userManager.UpdateAsync(user);\r\n\t}\r\n\r\n\tawait _signInManager.RefreshSignInAsync(user);\r\n\tStatusMessage = \"Your profile has been updated\";\r\n\treturn RedirectToPage();\r\n}\r\n```\r\n\r\nSo, after all the changes described above your User Profile page after that registration will look like this:\r\n\r\n<Image src={claim02Image} alt=\"User Profile form with ContactName field\" />\r\n\r\nNow, all the preparations are finished we can return back to our main task.\r\n\r\n\r\n## Step 1: Adding the contact name to the claims\r\nA funny thing: the main task is much easier than all the preparations we made before. :)\r\n\r\nThere are only two simple steps:\r\n\r\n### Create your own \"claims principal\" factory\r\n\r\nWe need an implementation `IUserClaimsPrincipalFactory` which will add necessary information (`ContactName` in our case) to the user claims.\r\nThe simplest way to do it - is to derive our new class from the default implementation of `IUserClaimsPrincipalFactory` and override one method: `GenerateClaimsAsync`:\r\n\r\n```csharp\r\npublic class MyUserClaimsPrincipalFactory : UserClaimsPrincipalFactory<ApplicationUser>\r\n{\r\n    public MyUserClaimsPrincipalFactory(\r\n        UserManager<ApplicationUser> userManager,\r\n        IOptions<IdentityOptions> optionsAccessor)\r\n        : base(userManager, optionsAccessor)\r\n    {\r\n    }\r\n\r\n    protected override async Task<ClaimsIdentity> GenerateClaimsAsync(ApplicationUser user)\r\n    {\r\n        var identity = await base.GenerateClaimsAsync(user);\r\n        identity.AddClaim(new Claim(\"ContactName\", user.ContactName ?? \"[Click to edit profile]\"));\r\n        return identity;\r\n    }\r\n}\r\n```\r\n\r\n### Register new class in DI container\r\n\r\nThen we need to register our new class in the dependency injection container.\r\nThe best way for that - to use `AddClaimsPrincipalFactory` extension method:\r\n\r\n```csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    .     .     .     .      .\r\n    services.AddDefaultIdentity<ApplicationUser>()\r\n        .AddDefaultUI(UIFramework.Bootstrap4)\r\n        .AddEntityFrameworkStores<ApplicationDbContext>()\r\n        .AddClaimsPrincipalFactory<MyUserClaimsPrincipalFactory>();  //<---- add this line\r\n}\r\n```\r\n\r\n## Step 2: Accessing new claim from the views\r\n\r\nNow we have a new claim associated with our user's identity. That's fine. But how we can get it and render on our view(s)?\r\nEasy. Any view in your application has access to `User` object which is an instance of `ClaimsPrincipal` class.\r\n\r\nThis object actually holds the list of all claims associated with the current user and you can call its `FindFirst` method to get the necessary claim and then read the `Value` property of that claim.\r\n\r\nSo, we just need to open `_LoginPartical.cshtml` file in `Pages/Shared/` (or `Views/Shared/`) folder and replace the following line:\r\n\r\n```html\r\n<a asp-area=\"\" asp-controller=\"Manage\" asp-action=\"Index\" title=\"Manage\">Hello @User.Identity.Name!</a>\r\n```\r\n\r\nwith this one:\r\n\r\n```html\r\n<a asp-area=\"\" asp-controller=\"Manage\" asp-action=\"Index\" title=\"Manage\">Hello @(User.FindFirst(\"ContactName\").Value)!</a>\r\n```\r\n\r\nNow, instead of something like `Hello john.doe@yourcompany.com` at the top of your web-page you should see something like this:\r\n\r\n<Image src={claim03Image} alt=\"ASP.NET Core - showing user's contact name instead of email\" />\r\n\r\nThat's all for now. Enjoy!";
						const data = {title:"Add extra user claims in ASP.NET Core webapp",date:new Date(1557187200000),cover:{src:"/images/sec-key.png",alt:"Alt text"},description:"So, the code in the following articles was built for and tested with ASP.NET Core 2.2. The main concept, however, is still the same and were not changed since ASP.NET Identity 2.0 (I guess)",draft:false,category:"general",tags:["ASP-NET-CORE","ASP-NET-IDENTITY","CLAIMS"],sort:5,relatedPosts:[{slug:"aspnet-identity-store-user-data-in-claims",collection:"blog"}]};
						const _internal = {
							type: 'content',
							filePath: "D:/Projects/sites/korzh.com/src/content/blog/2019-05-07-add-extra-user-claims-aspnet-core-webapp.mdx",
							rawData: "\r\ntitle: Add extra user claims in ASP.NET Core webapp\r\ntags: [\"ASP-NET-CORE\", \"ASP-NET-IDENTITY\", \"CLAIMS\"]\r\nslug: add-extra-user-claims-aspnet-core-webapp\r\ndate: 2019-05-07\r\ncover: {\r\nsrc: '/images/sec-key.png'\r\n}\r\nsort: 5\r\ndescription: So, the code in the following articles was built for and tested with ASP.NET Core 2.2. The main concept, however, is still the same and were not changed since ASP.NET Identity 2.0 (I guess)\r\nrelatedPosts:\r\n- aspnet-identity-store-user-data-in-claims\r",
						};

export { _internal, body, collection, data, id, slug };
