const id = "2020-08-10-asp-net-core-project-structure-explained-part2.mdx";
						const collection = "blog";
						const slug = "asp-net-core-project-structure-explained-part2";
						const body = "import {Image} from \"astro:assets\";\r\nimport middlewareImage from \"../../images/blog/aspnetcore-middleware-pipeline.png\"\r\n\r\n> This is the second part of the [article](asp-net-core-default-project-structure-explained-part-1), where we take apart the default ASP.NET Core solution template piece by piece and try to explain the purpose of each part and how exactly it works. You can consider it as a reference where you can check why a particular part was added to your project and find a link to the relevant documentation that explains it in detail.\r\n\r\n## Startup class\r\n\r\nAs we already mentioned in the first article, the Startup class is the entry point for all initialization codes in your application. Long story short, the Startup defines what your application will do and how exactly it will work.\r\n\r\nBy default, any Startup class in the ASP.NET Core application includes three main parts:\r\n\r\n* __The constructor__ where you can define some internal variables, set up some configuration settings, or perform application-wide initializations. For example, we suggest our users set here their license keys for our EasyQuery library.\r\n* __ConfigureServices__ method. Here we register all necessary services in the DI (dependency injection) container and define the configuration settings for some of them. In case you are not aware of what Dependency Injection is, here is an article on our blog that explains this concept in simple words.\r\n* __Configure__ method. This is the stage when you set up the middleware pipeline for your project.\r\n\r\nBoth `ConfigureServices` and `Configure` methods are called automatically while the application starts. You just need to define the services and the middlewares there correspondingly.\r\n\r\nNow, let’s take a look at each of these sections more in detail.\r\n\r\n### Startup class constructor\r\n\r\nThe default ASP.NET Core project template contains only the following one line of code in the constructor:\r\n\r\n```csharp\r\npublic Startup(IConfiguration configuration)\r\n{\r\n    Configuration = configuration;\r\n}\r\n```\r\n\r\nIt just saves in the class property the [configuration object](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1)\r\npassed here by the DI container, so we can use it in other methods.\r\nIn the [first article](asp-net-core-default-project-structure-explained-part-1),\r\nwe have already considered the configuration mechanism used in ASP.NET Core applications.\r\n\r\n### ConfigureServices method\r\n\r\nAs it was mentioned before, the `ConfigureServices` method contains the function calls that register different application services in the DI container.\r\nThese can be authentication/authorization services, MVC or Razor Pages engine, the classes for working with DB, or any other possible services.\r\n\r\nThe only parameter of the `ConfigureServices` method has `IServiceCollection` type that represents a list of `ServiceDescriptor` items.\r\nEach of those items maps some type (usually an interface) to a particular implementation of this type.\r\n\r\nAccording to the interface, we can use only usual `IList` or `ICollection` functions like `Add`, `AddRange`, `Remove`, and other methods.\r\nHowever, as you have already noticed, `ConfigureServices` contains such calls as `services.AddDbContext`, `services.AddRazorPages`, and similar.\r\nYou may ask, “How is it possible?” The answer is __extension methods__. Each sub-system used in our project (like Entity Framework Core or MVC engine) defines an extension method (sometimes even a few) for the `IServiceCollection` interface to simplify the registration in the DI and configuration of the services available in that sub-system.\r\n\r\n__NB__: Please note that the order of the services you register in the `ConfigureServices` method is not important.\r\nThis method is executed only once upon your application start.\r\n\r\nSo, let's take a closer look at the default ConfigureServices’ content.\r\n\r\n```csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddDbContext<ApplicationDbContext>(options =>\r\n        options.UseSqlServer(\r\n            Configuration.GetConnectionString(\"DefaultConnection\")));\r\n    services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)\r\n        .AddEntityFrameworkStores<ApplicationDbContext>();\r\n    services.AddRazorPages();\r\n}\r\n```\r\n\r\nSo, there are only three calls there: `AddDbContext`, `AddDefaultIdentity`, and `AddRazorPages`. Let’s inspect each of them separately.\r\n\r\n#### AddDbContext\r\n\r\nThis method is provided by the [Entity Framework Core](https://docs.microsoft.com/en-us/ef/core/) framework. It registers and configures our database context. The `Action`delegate passed in the parameter allows us to define the parameters of this DbContext. For example, with `UseSqlServer` call, we tell our DbContext to use a particular type of connection (`SqlConnection`) with a particular connection string. The connection string itself is taken from the configuration so it can be easily changed in Development or Production environments. You can find the default connection string in the `appsettings.json` configuration file, which we already analyzed in the [first article](https://korzh.com/blog/asp-net-core-project-structure-explained-part1).\r\n\r\n##### A few words about the “Builder” pattern\r\n\r\nYou may have noticed an interesting way of passing settings for DbContext.\r\nInstead of sending an object with options, we use a procedure (Action) with one-parameter options of the DbContextOptionsBuilder type.\r\n\r\nThat's because, to construct the DbContext settings properly, Entity Framework Core uses the __Builder Pattern__.\r\nThis pattern is helpful when you need to perform several steps to construct some complex objects and simply defining a class or structure is not enough. For example, when you need to call some methods depending on the settings in the configuration.\r\nAs it happens in our case with `UseSqlServer()`.\r\n\r\nThere is one more reason why we use a delegate (function) instead of a plain object.\r\nThere may be a situation when you don't need that service (DbContext) at all.\r\nFor example, your web app has some actions that do not require database access.\r\nThe DbContext object will never be created for such requests, and so, we will not need to set its options.\r\nThe good thing about a delegate is that it can be called exactly when you need to construct the necessary object.\r\n\r\nI paid so much attention to this pattern because it is used quite often,\r\nespecially in the process of registering services in DI (and we will use that for the next function call as well).\r\n\r\n#### AddDefaultIdentity\r\n\r\nThe second function call in the ConfigureServices was added here because of the Authentication option we turned on when creating our project.\r\nIt registers a bunch of services for authentication and authorization tasks such as `IUserStore`, `IRoleStore`, `IPasswordHasher`, `UserManager`, `SignInManager`, and many others.\r\nThe are all part of the ASP.NET Core Identity sub-system.\r\n\r\nThis method also uses the Builder Pattern, but in a slightly different way. Instead of passing the builder in the delegate’s parameter, this function returns an IdentityBuilder object, so you can call other functions with simple chaining.\r\n\r\nThe only function called there is `AddEntityFrameworkStores`.\r\nIt tells ASP.NET Identity where to store all the entities required for auth tasks (users, roles, claims, etc.).\r\nAs the name of the method suggests, we will use our Entity Framework services for these tasks.\r\nThe type of parameter in this method (between `< .. >`) defines the `DbContext` class used to store all auth objects.\r\n\r\n### AddRazorPages\r\n\r\nThe last function call in the `ConfigureServices` adds the services necessary for Razor Pages engine.\r\nIt appears here because of the template we chose at the beginning.\r\nIf we had selected a template with Model-View-Controller approach at that point, we would have had something like `services.AddMvc()` here.\r\n\r\n## Configure method\r\n\r\nThe last method in the Startup class defines the middleware pipeline of our ASP.NET Core program.\r\nIf you don't know what a middleware pipeline is, you might want to learn more about it because it determines how your web application handles HTTP requests.\r\n\r\n<Image src={middlewareImage} alt=\"ASP.NET Core middleware pipeline\" />\r\n\r\nUnlike the services registered in `ConfigureServices` (remember, their order is not important), the order of middlewares defined in `Configure` has crucial significance. As you can see from the picture above, the first defined middleware is called for each request while every next one in the pipeline processes only those requests that were not processed by the middlewares defined before it.\r\n\r\nSo at the beginning of the pipeline, we need to place the middlewares that are necessary for auxiliary tasks (like logging or authentication) and that don’t consume a lot of memory and processing time.\r\n\r\nLet’s take a look at the default implementation of this method for the chosen project template:\r\n\r\n```csharp\r\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\r\n{\r\n    if (env.IsDevelopment()) {\r\n        app.UseDeveloperExceptionPage();\r\n        app.UseDatabaseErrorPage();\r\n    }\r\n    else {\r\n        app.UseExceptionHandler(\"/Error\");\r\n        app.UseHsts();\r\n    }\r\n\r\n    app.UseHttpsRedirection();\r\n    app.UseStaticFiles();\r\n\r\n    app.UseRouting();\r\n\r\n    app.UseAuthentication();\r\n    app.UseAuthorization();\r\n\r\n    app.UseEndpoints(endpoints => {\r\n        endpoints.MapRazorPages();\r\n    });\r\n}\r\n```\r\n\r\nSo, let’s go through the middlewares defined here one by one.\r\n\r\n#### Exception handling and security transport\r\n\r\nThe first lines define different middlewares for Development and Production modes.\r\nIf we are in the Development mode, we define the middlewares that catch all exceptions in the pipeline\r\nand show a special page with extra information about the error (exception message, stack trace, etc.).\r\n\r\nIt's possible to do because (as you can see from the image above) the processing of the request is returned to the first middleware\r\nin the pipeline before being sent back to the client.\r\n\r\nIn the Production mode, we also catch all exceptions and then re-execute the request with the specified path (‘/Error’ in our case).\r\n\r\nThe second call executed only in Production is `UseHsts`. It adds a middleware that implements HTTP Strict Transport Security Protocol.\r\n\r\nThe next in the pipeline is HTTPS redirection middleware (`app.UseHttpsRedirection`).\r\nThe name is self-explanatory. It just redirects all HTTP requests to HTTPS ones.\r\nThese two middlewares (`app.UseHsts` and `app.UseHttpsRedirection` calls) are added because of the __Configure for HTTPS__ option we turned on (actually, it was turned on by default) during the project creation.\r\n\r\n#### Processing static files (UseStaticFiles)\r\n\r\nThe next middleware (added by the `app.UseStaticFiles()` call) takes care of all static files.\r\nSimply put, if the application gets a request for some .js, .css, or an image file (.png, .jpg, etc.),\r\nthis middleware looks for a file with the requested name inside `wwwroot` folder and returns it in response (if the file was found).\r\nIf not, it sends back a response with a 404 status code (“not found”).\r\n\r\nThere are overloads of `UseStaticFiles` that allow us to define another root folder for static files and set some other options.\r\n\r\n#### Routing (UseRouting and UseEndpoints)\r\n\r\nThe next pair of middlewares are, maybe, the most important ones in the pipeline, since they define the routing for all other endpoints in your web app.\r\n\r\nIn simple words, they match a particular request to a particular endpoint, a piece of executable code that handles the request.\r\n\r\nSo, how exactly does it work?\r\n\r\nIn the `Configure` method, we call `app.UseRouting()` to add `EndpointRoutingMiddleware` to our pipeline.\r\n\r\nAfter that, we call `app.UseEndpoints()` to add `EndpointMiddleware` to the pipeline and define the endpoints. Each endpoint is an object that contains (as mentioned above) a delegate (so, a piece of code) that actually handles the request, plus some metadata (like an authorization policy).\r\n\r\nWe can use such extension methods as `MapGet`, `MapPost`, and others to add an endpoint that matches a particular request path or a path template. For example, the following pattern `/something/{path*}`, will be matched for all requests started with `/something/`.\r\n\r\nAdditionally, other services can define their own extension functions that are used to create necessary endpoints. For example, you can use the `MapRazorPages` function for Razor Pages or `MapHub` for SingleR. In our [EasyData library](https://github.com/KorzhCom/EasyData) we defined `MapEasyData` function that adds an endpoint for the API that processes all CRUD operations.\r\n\r\nWhen our web app gets a new request (and it’s not processed by any middleware defined before `UseRouting`), the `EndpointRoutingMiddleware` matches it to some endpoint. So, one endpoint among all defined at the application start is becoming selected at that moment.\r\n\r\nThen `EndpointMiddleware` actually calls the endpoint’s delegate to handle the request.\r\nOther middlewares that are added after `app.UseRouting()` but before `app.UseEnpoints()` can see which endpoint is selected\r\nand can change something (e.g., to apply an authorization policy) before `EndpointMiddleware` dispatches to the selected endpoint.\r\n\r\n\r\n#### Authentication/Authorization (UseAuthentication, UseAuthorization)\r\n\r\nThese two middlewares are added in the `Configure` because of the Authentication option we turned on when we created our project.\r\nAs already mentioned above, they already know which endpoint is selected and so can add some additional identity-related information to the request’s context (like filling its `User` property) or redirect to the “sign-in/sign up” pages if the current request is anonymous but the selected endpoint requires authorization.\r\n\r\n## Wrapping Up\r\n\r\nSo, in this article, I tried to cover all pieces of one of the most-used ASP.NET Core application templates and figure out why they are used and how they work (from a very general point of view).\r\n\r\nI hope this information will help you better understand the internal mechanism of the ASP.NET Core framework and make your code more clear and efficient.\r\n\r\nThanks for the reading, and take care!";
						const data = {title:"ASP.NET Core default project structure explained (part 2)",date:new Date(1597017600000),cover:{src:"/images/computer-coffee-02.jpg",alt:"Alt text"},description:"As we already mentioned in the first article, the Startup class is the entry point for all initialization codes in your application. Long story short, the Startup defines what your application will do and how exactly it will work",draft:false,category:"general",tags:["ASP-NET-CORE","PROJECT-TEMPLATE"],sort:5,relatedPosts:[{slug:"asp-net-core-default-project-structure-explained-part-1",collection:"blog"}]};
						const _internal = {
							type: 'content',
							filePath: "D:/Projects/sites/korzh.com/src/content/blog/2020-08-10-asp-net-core-project-structure-explained-part2.mdx",
							rawData: "\r\ntitle: ASP.NET Core default project structure explained (part 2)\r\ntags: [\"ASP-NET-CORE\", \"PROJECT-TEMPLATE\"]\r\nslug: asp-net-core-project-structure-explained-part2\r\ndate: 2020-08-10\r\ncover: {\r\nsrc: '/images/computer-coffee-02.jpg'\r\n}\r\nsort: 5\r\ndescription: As we already mentioned in the first article, the Startup class is the entry point for all initialization codes in your application. Long story short, the Startup defines what your application will do and how exactly it will work\r\nrelatedPosts:\r\n- asp-net-core-default-project-structure-explained-part-1\r",
						};

export { _internal, body, collection, data, id, slug };
