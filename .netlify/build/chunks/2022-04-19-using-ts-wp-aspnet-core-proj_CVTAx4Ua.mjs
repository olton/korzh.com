const id = "2022-04-19-using-ts-wp-aspnet-core-proj.mdx";
						const collection = "blog";
						const slug = "typescript-webpack-aspnetcore";
						const body = "## Motivation\r\n\r\nSuppose you work on ASP.NET Core web application that solves some business-related tasks. You know, a few forms where users enter their data and get some reports. Although such a project may not require any complex logic on the client, you still probably need to write some JavaScript code to make user interaction with your application more convenient and enjoyable. For example, you may need a simple prompt popup on item deletion since it's not quite right to use a separate page for that. Or, you want to do client-side validation. Or ... it really can be any other client-side task, you name it.\r\n\r\nOf course, you can add a few lines of script on each page (with vanilla JavaScript or using the good old JQuery) but it is really hard to maintain all these small pieces when your project gets bigger. Moreover, some of these pieces do the same things, so you either need to replicate them in many places (bad decision) or you end up creating a small library that contains all client-side functions, structures, and classes used in your project.\r\n\r\nThis article describes how to create such a JS library for your ASP.NET Core project with minimal effort and in a way that will provide better support for further changes.\r\n\r\n## Solution\r\n\r\nLong story short, we are going to put all our client-side code to separate files (with classes, functions, data structures) and then bundle them with the help of WebPack 5. The resulting script can be included right into your _Layout.cshtml (so, it will be available on all pages of your web app) or you can include it only on the pages where it's necessary.\r\n\r\nMoreover, we will use TypeScript instead of pure JavaScript because, you know, static typing is good and it allows us to catch a lot of errors at compile time.\r\n\r\nIn addition, you can consider this article as a quick introduction to client-side development. Especially if you are a .NET developer who still tends to stay backend-only and who is afraid of all that fancy client-side stuff (as I was some time ago).\r\n\r\n## Getting started\r\n\r\nHere we will describe the steps necessary to set up the configuration for bundling a small TypeScript library with your own code. For the sake of simplification, this library will contain just one function for now.\r\n\r\n### 0. Install Node.JS\r\n\r\nI'm pretty much sure you already have it installed. In case you don't - please do it. We will need Node.JS version 10.13.0 (or newer) on your dev/build machine.\r\n\r\n### 1. ClientScript sub-folder\r\n\r\nWe will put all our scripts and configuration files into a separate sub-folder ClientScript of your main project's folder. It's similar to ClientApp sub-folder used in most of the SPA (single page application) templates available for ASP.NET Core.\r\n\r\n### 2. Add configuration files\r\n\r\nWe will need 3 configuration files:\r\n\r\n- package.json - to define our bundle and all dependencies,\r\n- webpack.config.js - for WebPack configuration\r\n- tsconfig.json - for TypeScript settings.\r\n\r\nFor now, you can just copy these files as-is. We will describe each of them later.\r\n\r\n```json title=\"package.json\"\r\n{\r\n  \"name\": \"myapp-client-bundle\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"This is client-side scripts bundle for MyApp\",\r\n  \"private\": true,\r\n  \"scripts\": {\r\n    \"build\": \"webpack --mode=development\",\r\n    \"build:prod\": \"webpack --mode=production\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"ts-loader\": \"^9.2.5\",\r\n    \"typescript\": \"^4.4.3\",\r\n    \"webpack\": \"^5.52.1\",\r\n    \"webpack-cli\": \"^4.8.0\"\r\n  },\r\n  \"dependencies\": {\r\n  }\r\n}\r\n```\r\n\r\n```javascript title=\"webpack.config.js\"\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n  entry: './src/index.ts',\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.tsx?$/,\r\n        use: 'ts-loader',\r\n        exclude: /node_modules/,\r\n      },\r\n    ],\r\n  },\r\n  resolve: {\r\n    extensions: ['.tsx', '.ts', '.js'],\r\n  },\r\n  output: {\r\n    library: {\r\n      name: 'MYAPP',\r\n      type: 'var'\r\n    },\r\n    filename: 'app-client.js',\r\n    path: path.resolve(__dirname, '../wwwroot/js'),\r\n  }\r\n};\r\n```\r\n\r\n```json title=\"tsconfig.json\"\r\n{\r\n  \"compilerOptions\": {\r\n    \"outDir\": \"./dist/\",\r\n    \"noImplicitAny\": true,\r\n    \"module\": \"es6\",\r\n    \"target\": \"es5\",\r\n    \"allowJs\": true,\r\n    \"moduleResolution\": \"node\"\r\n  }\r\n}\r\n```\r\n\r\n### 3. Add TypeScript files\r\n\r\nFor the sake of simplicity, our library in this initial stage will contain only one function hello() that simply prints Hello world to the browser's console. Here are two files we need for that outstanding :) functionality:\r\n\r\n#### hello.ts\r\nThis file contains our function packed into the funcs namespace, so we will be able to call it as MYAPP.funcs.hello()\r\n\r\n```typescript title=\"hello.ts\"\r\nexport namespace funcs {\r\n    export function hello(): void {\r\n        const message = 'Hello world!';\r\n        console.log(message);\r\n    }\r\n}\r\n```\r\n#### index.ts\r\nThis is our entry point. This TypeScript file will not contain any functions or classes. It will just define which parts of our code (functions, interfaces, classes, etc) we are going to expose to the outside world. Since we have only one file with \"real\" functionality our index.ts will as simple as:\r\n```typescript title=\"index.ts\"\r\nexport * from './hello';\r\n```\r\nand it means that we would to \"reveal\" all public (exported) parts inside our `hello.ts`\r\n\r\n### 4. Build your library\r\n\r\nThat's it. We are ready to build our bundle script. To do so, open your terminal program, move to `ClientScript` folder and run the following 2 commands:\r\n\r\n```shell\r\nnpm install\r\n```\r\nand then\r\n```shell\r\nnpm run build\r\n```\r\n\r\nThe first one will install all necessary NPM libraries (the ones which are listed in the `dependencies` and `devDependencies` sections of your `package.json`). You will need to run it before the first build and then only when you add a new dependency (another NPM package) to your `package.json`.\r\n\r\nThe second command actually runs WebPack that compiles (or, to be more correct, \"transpiles\") your TypeScript files to JavaScript, then bundles all JS code into one file `app-client.js` and puts that file into `wwwroot/js` folder of your web project as defined in `webpack.config.js` configuration file.\r\n\r\nAccording to the `output/library` section of that file, all functions or structures of your new bundle will be accessible via the `MYAPP` global variable.\r\n\r\n### 5. Attach the final script to your app\r\nTo use our script you just need to include it on your page as any other JS file:\r\n```html\r\n<script src=\"/js/app-client.min.js\"></script>\r\n```\r\nYou can add that line either to the `_Layout.cshtml` (to make it available on all pages of your web application) or to the view or Razor page where it's necessary.\r\n\r\nNow you can call the function(s) from our new JS library:\r\n```html\r\n<script>\r\nMYAPP.funcs.hello();\r\n</script>\r\n```\r\n\r\n## Configuring the scope\r\n\r\nOne of the great features of using TypeScript and WebPack is organizing your code in modules and then combining those modules into namespaces using WebPack's configuration and TypeScript's `namespace` structure.\r\n\r\nThere are several possible options.\r\n\r\n### 1. Use module names and their aliases\r\nYou can put functions and classes in a module and export that module either \"as-is\" or with an alias.\r\n\r\nFor example, if we have the following module:\r\n```typescript title=\"dialogs.ts\"\r\nexport class Dialog {\r\n    ...\r\n}\r\n\r\nexport function showDialog() {\r\n    ...\r\n}\r\n```\r\nand we use this export declaration in our `index.ts`:\r\n```typescript\r\nexport * from './dialogs';\r\n```\r\nthen our `Dialog` class and `showDialog()` function will be available right under `MYAPP` namespace as `MYAPP.Dialog` and `MYAPP.showDialog()`.\r\n\r\nYou can also specify an alias for that `dialogs` module:\r\n```typescript\r\nexport * as dlg from './dialogs';\r\n```\r\nNow our class and the function will be accessible as `MYAPP.dlg.Dialog` and `MYAPP.dlg.showDialog()` correspondingly.\r\n\r\n### 2. Using namespace clause\r\n\r\nYou can also use the namespace clause and then re-export the imported modules, so all functions, variables, and types that belong to the same namespace even in different modules will be merged together.\r\n\r\nFor example, we have the following two modules:\r\n\r\n```typescript title=\"dialogs.ts\"\r\nexport namespace ui {\r\n    export class Dialog1 {\r\n        ...\r\n    }\r\n\r\n    export function showDialog1() {\r\n        ...\r\n    }\r\n}\r\n```\r\nand\r\n```typescript title=\"widgets.ts\"\r\nexport namespace ui {\r\n  export class Widget1 { ... }\r\n\r\n  export function renderWidget1() { ... }\r\n}\r\n```\r\nw, if we place the following two lines in our `index.ts` module:\r\n```typescript\r\nexport * from './dialogs';\r\nexport * from './widgets';\r\n```\r\nwe will be able to access all those exported functions and classes under the `MYAPP.ui` namespace. For example: `MYAPP.ui.renderWidget1()`.\r\n\r\n## Using third-party libraries\r\n\r\nMaybe the most significant advantage of this setup (that may seem a little complicated for just a \"hello world\" function) is the possibility to use any third-party JS library from hundred of thousands available on NPM repository.\r\n\r\nAs an example, we slightly modify our `hello()` function so that it will take a parameter `name` and will print the phrase `Hello, {name}` to the console. Before printing, the string stored in the name variable will be capitalized with the help of `capitalize()` function from the well-known `lodash` library.\r\n\r\nHere are the steps we should take to achieve this goal:\r\n\r\n### 1. Add lodash library to your package.json\r\n\r\nJust open a terminal inside your ClientScript folder and type:\r\n```shell\r\nnpm install lodash\r\n```\r\nAs the result of this operation, you will see something like the following in the dependencies section of your package.json file:\r\n```json\r\n\"dependencies\": {\r\n    \"lodash\": \"^4.17.21\"\r\n}\r\n```\r\n(the actual version number can be different).\r\n\r\n### 2. Import lodash functions in your hello.ts file\r\n\r\nAdd the following line at the beginning of hello.ts:\r\n```typescript\r\nimport * as _ from 'lodash';\r\n```\r\n\r\n### 3. Modify hello() function\r\n\r\nNow we can use all lodash library functions using _ global variable (this is the default way of using lodash functions since the times it was not an NPM library). So, our hello function will look the following:\r\n\r\n```typescript\r\nexport function hello(name : string): void {\r\n  const message = 'Hello, ' + _.capitalize(name);\r\n  console.log(message);\r\n}\r\n```\r\nAdditionally, we will modify the function call on our page:\r\n```html\r\n<script>\r\nMYAPP.funcs.hello('sergiy');\r\n</script>\r\n```\r\nWhen we rebuild our script (npm run build), run the app, and open the main page, we will see the following string in the console panel of our browser:\r\n```\r\nHello, Sergiy\r\n```\r\n\r\n## Watch mode\r\nIt's unnecessary to run the build command each time you change something in your script or add a new package to your project. Instead, you can use the watch mode once, and WebPack will re-build your project every time something was changed:\r\n\r\n```shell\r\nnpm run watch\r\n```\r\n\r\n## Conclusions\r\n\r\nAs we can see, using TypeScript with WebPack to build vanilla JS client-side scripts for your ASP.NET Core projects has a lot of benefits:\r\n\r\n- Strong-typed TypeScript code with all advantages of the latest JavaScript features: classes, arrow functions, modules, scopes, and promises.\r\n- Better support by code editors (like Visual Studio Code) with syntax highlighting, IntelliSense, etc.\r\n- A possibility to use 3-party libraries with typing definitions.\r\n- More compact and optimized JS 5 code generated by WebPack.\r\n- Hot reload of the changes you make in the code editor.\r\n- Better debugging experience (I'm going to write a separate article about it). It's possible to debug your original TypeScript code instead of minimized JS code available for your web app.\r\n\r\nThere is one more note. We used WebPack in this article since it's the most popular module bundler for now. However, I believe that we can quickly get the same results with any other bundler like Browserify, Parcel, or Rollup.\r\n\r\nPlease let me know (via my Twitter account @korzhs or here in the comments) if this article was valuable and informative for you.\r\n\r\nHappy coding!";
						const data = {title:"Using TypeScript with WebPack in ASP.NET Core projects",date:new Date(1650326400000),cover:{src:"/images/tswebpack-cover.jpg",alt:"Alt text"},description:"Suppose you work on ASP.NET Core web application that solves some business-related tasks. You know, a few forms where users enter their data and get some reports. Although such a project may not require any complex logic on the client, you still probably need to write some JavaScript code to make user interaction with your application more convenient and enjoyable",draft:false,category:"general",tags:["ASP-NET-CORE","JAVASCRIPT","TYPESCRIPT"],sort:5};
						const _internal = {
							type: 'content',
							filePath: "D:/Projects/sites/korzh.com/src/content/blog/2022-04-19-using-ts-wp-aspnet-core-proj.mdx",
							rawData: "\r\ntitle: Using TypeScript with WebPack in ASP.NET Core projects\r\ntags: [\"ASP-NET-CORE\", \"JAVASCRIPT\", \"TYPESCRIPT\"]\r\nslug: typescript-webpack-aspnetcore\r\ndate: 2022-04-19\r\ncover: {\r\nsrc: '/images/tswebpack-cover.jpg'\r\n}\r\nsort: 5\r\ndescription: \"Suppose you work on ASP.NET Core web application that solves some business-related tasks. You know, a few forms where users enter their data and get some reports. Although such a project may not require any complex logic on the client, you still probably need to write some JavaScript code to make user interaction with your application more convenient and enjoyable\"\r",
						};

export { _internal, body, collection, data, id, slug };
